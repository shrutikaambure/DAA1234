<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E-Waste Recycling and Water Pollution Monitoring</title>
    <style>
        body {
            background-color: pink;
            color: black;
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
        }
        .header {
            text-align: center;
            color: red;
            font-size: 32px;
            margin-top: 20px;
            animation: fadeInDown 2s ease-in-out;
        }
        .section {
            border: 2px solid red;
            padding: 20px;
            margin: 20px auto;
            width: 90%;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            background-color: white;
            border-radius: 10px;
            animation: slideInUp 2s ease-in-out;
        }
        .title {
            font-size: 28px;
            color: red;
            margin-bottom: 10px;
            animation: fadeInUp 2s ease-in-out;
        }
        .content {
            margin-left: 20px;
            text-align: justify;
            font-size: 18px;
            line-height: 1.6;
            animation: fadeInUp 2s ease-in-out;
        }
        pre {
            background-color: #f8f8f8;
            padding: 15px;
            border: 1px solid #ddd;
            overflow-x: auto;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            animation: fadeInUp 2s ease-in-out;
        }
        ul {
            padding-left: 20px;
        }

        /* Animations */
        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-50px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideInUp {
            from { opacity: 0; transform: translateY(50px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(50px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="header">E-Waste Recycling and Water Pollution Monitoring</div>
    
    <div class="section">
        <div class="title">E-Waste Recycling</div>
        <div class="content">
            <strong>Description:</strong> Create a platform for collecting, refurbishing, and reselling e-waste or extracting valuable materials.<br>
            <strong>Technique Used:</strong> Queues<br>
            <strong>Why Queues are Used:</strong> 
     <ul>
            <li>FIFO (First-In-First-Out): A queue follows the First-In-First-Out principle, meaning the first element added is the first one to be processed. This ensures that items are processed in the order they arrive.</li>
            
            <li>Fairness: For tasks like e-waste management, maintaining fairness and order is critical. Each item gets processed in the order it comes, ensuring no item is skipped or delayed.</li>
            
            <li>Example Use Case: In e-waste recycling systems, items such as old computers or electronics arrive at different times, and using a queue ensures they are processed in the order they were received.</li>
            
            <li>Performance: By processing one item at a time, queues avoid the complexity of backtracking or repeated processing, making the system more efficient.</li>
        </ul><br>
            <strong> QUEUE Code in C++:</strong>
            <pre>
                #include <iostream>
                    #include <queue>
                    #include <string> // Include string for using strings in the queue
                    
                    using namespace std;
                    
                    int main() {
                        // Create a queue to store string elements
                        queue<string> eWaste;
                    
                        // Add elements to the queue
                        eWaste.push("Laptop");
                        eWaste.push("Mobile");
                        eWaste.push("Tablet");
                    
                        // Process elements from the queue
                        cout << "Processing e-Waste items:" << endl;
                        while (!eWaste.empty()) {
                            // Access and display the front element
                            cout << "Processing: " << eWaste.front() << endl;
                            // Remove the processed element
                            eWaste.pop();
                        }
                    
                        cout << "All e-Waste items have been processed!" << endl;
                    
                        return 0;
                    }
                    
            </pre>
            <strong>SDG Addressed:</strong> SDG 12 - Responsible Consumption and Production<br>
            <strong>Addressing:</strong> Encourages the sustainable management and recycling of e-waste, reducing environmental harm and conserving resources.
        </div>
    </div>
    
    <div class="section">
        <div class="title">Water Pollution Monitoring</div>
        <div class="content">
            <strong>Description:</strong> Offer IoT-based water quality monitoring systems to industries, municipalities, and agricultural sectors.<br>
            <strong>Technique Used:</strong> Heap, Dijkstra’s Algorithm<br>
            <strong>Why Heap and Dijkstra's Algorithm Are Used:</strong> 
            <ul>
                <li><strong>Heap:</strong> <ul>
                    <li>Priority Queue Operations: A heap is a data structure that allows efficient retrieval and removal of the element with the highest or lowest priority.</li>
                    
                    <li>Optimal Path Finding: In Dijkstra’s algorithm, heaps are used to maintain a priority queue of nodes based on their shortest known distance, which allows for fast selection of the node with the minimum distance.</li>
                    
                    <li>Efficiency in Sorting & Searching: Heaps provide a means to sort elements in log-linear time complexity, which is faster than traditional sorting techniques like quicksort or mergesort.</li>
                    
                    <li>Use Case in Water Pollution Monitoring: In monitoring systems, heaps help maintain the priority order of water pollution data, ensuring the most urgent or critical points are prioritized first for data collection or analysis.</li>
                    
                    </ul></li>
                <li><strong>Dijkstra's Algorithm:</strong><ul>
                    <li>Shortest Path Problem: Dijkstra’s algorithm is specifically designed to find the shortest path from a source node to all other nodes in a graph with non-negative weights.</li>
                    
                    <li>Efficient Routing: In water pollution monitoring, the algorithm helps calculate the shortest paths for sensor data collection or the least polluted routes for water flow, ensuring optimal resource allocation.</li>
                    
                    <li>Greedy Approach: It makes use of a greedy approach by selecting the node with the shortest known distance, thus optimizing the performance in scenarios with weighted graphs (like networks for water pollution).</li>
                    
                    <li>Use Case in Water Quality Monitoring: In water pollution systems, nodes represent locations, edges represent distances, and weights represent pollution levels. Dijkstra helps determine optimal monitoring points or areas that need immediate attention.</li>
                    
                    <li>Scalability: Dijkstra’s algorithm works efficiently even as<b> the number of nodes as city(river) , distance(kms) and edges  defines us percentage of that river how much it is water pollutated increases, which is crucial for large-scale water pollution monitoring systems.</b></li>
                    </ul>
                    
                     </li>
                     By utilizing these data structures and algorithms, we optimize performance, maintain order, and ensure the efficient processing and analysis of e-waste and water pollution.
            </ul>
            <strong>Heap Algorithm:</strong>
            <pre>
               
                #include <iostream>
                    #include <utility> // For pair
                    
                    using namespace std;
                    
                    // Function to heapify the tree
                    void heapify(pair<string, int> arr[], int n, int I) {
                        int largest = I;          // Initialize largest as root
                        int left = 2 * I + 1;     // Left child index
                        int right = 2 * I + 2;    // Right child index
                    
                        // Check if left child exists and is greater
                        if (left < n && arr[left].second > arr[largest].second)
                            largest = left;
                    
                        // Check if right child exists and is greater
                        if (right < n && arr[right].second > arr[largest].second)
                            largest = right;
                    
                        // If largest is not root
                        if (largest != I) {
                            swap(arr[I], arr[largest]);
                            heapify(arr, n, largest);
                        }
                    }
                    
                    // Function to perform heap sort
                    void heapsort(pair<string, int> arr[], int n) {
                        // Build max heap
                        for (int I = n / 2 - 1; I >= 0; I--)
                            heapify(arr, n, I);
                    
                        // Extract elements from heap
                        for (int I = n - 1; I > 0; I--) {
                            swap(arr[0], arr[I]); // Move current root to end
                            heapify(arr, I, 0);   // Heapify reduced heap
                        }
                    }
                    
                    int main() {
                        // Array of water pollution sources with their contributions
                        pair<string, int> pollutionSources[] = {
                            {"Industrial Waste", 60},
                            {"Plastic", 70},
                            {"Sewage", 50},
                            {"Agricultural Runoff", 80},
                    
                        };
                    
                        int n = sizeof(pollutionSources) / sizeof(pollutionSources[0]);
                    
                        // Display original array
                        cout << "Original Water Pollution Sources and Contributions:\n";
                        for (int I = 0; I < n; I++)
                            cout << pollutionSources[I].first << ": " << pollutionSources[I].second << "%\n";
                    
                        // Sort pollution sources by contribution percentage
                        heapsort(pollutionSources, n);
                    
                        // Display sorted array
                        cout << "\nWater Pollution Sources Sorted by Contribution Levels:\n";
                        for (int I = 0; I < n; I++)
                            cout << pollutionSources[I].first << ": " << pollutionSources[I].second << "%\n";
                    
                        return 0;
                    }
                    
            </pre>
            <strong>Dijkstra Algorithm in C++:</strong>
            <pre>
                #include <iostream>
                    #include <vector>
                    #include <unordered_map>
                    
                    // Structure to represent edges in the graph
                    struct Edge {
                        int destination;  // Destination city
                        int distance;     // Distance in kilometers
                        int pollution;    // Pollution level in percentage
                    };
                    
                    // Function to display distances and pollution levels for outgoing connections
                    void displayConnections(const std::vector<std::vector<Edge>>& graph, int start, const std::unordered_map<int, std::string>& cityMap) {
                        std::cout << "Connections from Ahmednagar with Distances and Pollution Levels\n\n";
                        std::cout << "Start City: " << cityMap.at(start) << "\n\n";
                    
                        std::cout << "City\t\t\t\tDistance (km)\tPollution Level (%)\n";
                        std::cout << "-----------------------------------------------------------\n";
                    
                        for (const Edge& edge : graph[start]) {
                            std::cout << cityMap.at(edge.destination) << "\t\t" << edge.distance << "\t\t" << edge.pollution << "%\n";
                        }
                    }
                    
                    int main() {
                        // Define the graph (adjacency list representation)
                        std::vector<std::vector<Edge>> graph = {
                            {{1, 120, 25}, {2, 200, 20}, {3, 300, 30}},  // Ahmednagar -> Pune (120 km, 25%), Nashik (200 km, 20%), Solapur (300 km, 30%)
                            {{4, 150, 15}},                              // Pune -> Aurangabad (150 km, 15%)
                            {{4, 180, 10}, {5, 500, 35}},               // Nashik -> Aurangabad (180 km, 10%), Nagpur (500 km, 35%)
                            {{5, 400, 40}},                             // Solapur -> Nagpur (400 km, 40%)
                            {{5, 300, 20}},                             // Aurangabad -> Nagpur (300 km, 20%)
                            {}                                          // Nagpur (no outgoing connections)
                        };
                    
                        // Map node indices to city names
                        std::unordered_map<int, std::string> cityMap = {
                            {0, "Ahmednagar"},
                            {1, "Pune (via Godavari)"},
                            {2, "Nashik (via Godavari)"},
                            {3, "Solapur (via Bhima)"},
                            {4, "Aurangabad (via Kham)"},
                            {5, "Nagpur (via Kanhan)"}
                        };
                    
                        // Display distances and pollution levels for outgoing connections from Ahmednagar
                        displayConnections(graph, 0, cityMap);
                    
                        return 0;
                    }
                    
            </pre>
            <strong>SDG Addressed:</strong> SDG 6 - Clean Water and Sanitation<br>
            <strong>Addressing:</strong> Ensures access to safe water by monitoring pollution levels and improving water quality for sustainable water management.
        </div>
    </div>
</body>
</html>